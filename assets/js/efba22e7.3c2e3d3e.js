"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[146],{876:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>y});var a=t(2784);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(t),m=i,y=u["".concat(s,".").concat(m)]||u[m]||p[m]||l;return t?a.createElement(y,o(o({ref:n},c),{},{components:t})):a.createElement(y,o({ref:n},c))}));function y(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var d=2;d<l;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3617:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var a=t(7896),i=(t(2784),t(876));const l={id:"scene-layout",title:"Building a scene layout"},o=void 0,r={unversionedId:"scene-layout",id:"scene-layout",title:"Building a scene layout",description:"Scenes support two layout types: flex and grid layout. In this guide you will learn how to use and configure SceneFlexLayout and SceneGridLayout.",source:"@site/../docs/scene-layout.md",sourceDirName:".",slug:"/scene-layout",permalink:"/scenes/docs/scene-layout",draft:!1,editUrl:"https://github.com/grafana/scenes/edit/main/docusaurus/website/../docs/scene-layout.md",tags:[],version:"current",frontMatter:{id:"scene-layout",title:"Building a scene layout"}},s={},d=[{value:"Flexbox layout",id:"flexbox-layout",level:2},{value:"Step 1. Create a scene",id:"step-1-create-a-scene",level:3},{value:"Step 2. Configure flexbox layout",id:"step-2-configure-flexbox-layout",level:3},{value:"Step 3. Add layout children",id:"step-3-add-layout-children",level:3},{value:"Step 4. Add panels to flex layout items",id:"step-4-add-panels-to-flex-layout-items",level:3},{value:"Responsive flex layouts",id:"responsive-flex-layouts",level:3},{value:"Grid layout",id:"grid-layout",level:2},{value:"Step 1. Create a scene",id:"step-1-create-a-scene-1",level:3},{value:"Step 2. Configure grid layout",id:"step-2-configure-grid-layout",level:3},{value:"Step 3. Add layout children",id:"step-3-add-layout-children-1",level:3},{value:"Step 4. Add panels to grid layout items",id:"step-4-add-panels-to-grid-layout-items",level:3},{value:"Step 5. Add a grid row",id:"step-5-add-a-grid-row",level:3}],c={toc:d},u="wrapper";function p(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Scenes support two layout types: flex and grid layout. In this guide you will learn how to use and configure ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridLayout"),"."),(0,i.kt)("h2",{id:"flexbox-layout"},"Flexbox layout"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout")," allows building flexible scenes with layout driven by browser's CSS flexbox layout. This allows for defining very dynamic layouts where panel widths and heights can adapt to the available space."),(0,i.kt)("h3",{id:"step-1-create-a-scene"},"Step 1. Create a scene"),(0,i.kt)("p",null,"Start using flexbox layout by creating a scene with ",(0,i.kt)("inlineCode",{parentName:"p"},"body")," configured as ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  body: new SceneFlexLayout({}),\n});\n")),(0,i.kt)("h3",{id:"step-2-configure-flexbox-layout"},"Step 2. Configure flexbox layout"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout")," allows flexbox behavior configuration. You can configuere the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"direction")," - configure the main axis of flexbox layout. Children placed within the layout will follow it's direction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wrap")," - configure behavior of layout children. By default, children will try to fit into one line.")),(0,i.kt)("p",null,"By default SceneFlexLayout uses ",(0,i.kt)("inlineCode",{parentName:"p"},"row")," direction. To create colum layout, try the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  body: new SceneFlexLayout({\n    direction: 'column',\n  }),\n});\n")),(0,i.kt)("h3",{id:"step-3-add-layout-children"},"Step 3. Add layout children"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," property. It accepts an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexItem")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout")," objects.\nCreate scene with two, equally sized layout items in a column:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  body: new SceneFlexLayout({\n    direction: 'column',\n    children: [new SceneFlexItem({ minHeight: 200 }), new SceneFlexItem({ minHeight: 300})],\n  }),\n});\n")),(0,i.kt)("p",null,"Both ",(0,i.kt)("inlineCode",{parentName:"p"},"ScenFlexLayout")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexItem")," object types accept the following configuration options that allow size constraints and behaviors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"  flexGrow?: CSSProperties['flexGrow'];\n  alignSelf?: CSSProperties['alignSelf'];\n  width?: CSSProperties['width'];\n  height?: CSSProperties['height'];\n  minWidth?: CSSProperties['minWidth'];\n  minHeight?: CSSProperties['minHeight'];\n  maxWidth?: CSSProperties['maxWidth'];\n  maxHeight?: CSSProperties['maxHeight'];\n  xSizing?: 'fill' | 'content';\n  ySizing?: 'fill' | 'content';\n  // For sizing constaints on smaller screens\n  md?: SceneFlexItemPlacement;\n")),(0,i.kt)("p",null,"We really recommend setting a minHeight on all children of layout that use ",(0,i.kt)("inlineCode",{parentName:"p"},"column")," direction. This will make sure that they don't get squashed too much on smaller screens. If you set minHeight or height on a SceneFlexLayout you do not need\nto set it on each child as they will inherit these constraints."),(0,i.kt)("h3",{id:"step-4-add-panels-to-flex-layout-items"},"Step 4. Add panels to flex layout items"),(0,i.kt)("p",null,"The above example sets up layout for your scene. To visualize data, ",(0,i.kt)("a",{parentName:"p",href:"/scenes/docs/core-concepts#data-and-time-range"},"configure ",(0,i.kt)("inlineCode",{parentName:"a"},"SceneQueryRunner"))," and add it to your scene first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const queryRunner = new SceneQueryRunner({\n  $timeRange: new SceneTimeRange()\n  datasource: {\n    type: 'prometheus',\n    uid: '<PROVIDE_GRAFANA_DS_UID>',\n  },\n  queries: [\n    {\n      refId: 'A',\n      expr: 'rate(prometheus_http_requests_total{}[5m])',\n    },\n  ],\n});\n\nconst myScene = new EmbeddedScene({\n  $data: queryRunner,\n  body: new SceneFlexLayout({\n    direction: 'column',\n    children: [new SceneFlexItem({}), new SceneFlexItem({})],\n  }),\n});\n")),(0,i.kt)("p",null,"Next, add ",(0,i.kt)("inlineCode",{parentName:"p"},"VizPanel")," objects as ",(0,i.kt)("inlineCode",{parentName:"p"},"body")," of layout items:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const queryRunner = new SceneQueryRunner({\n  datasource: {\n    type: 'prometheus',\n    uid: '<PROVIDE_GRAFANA_DS_UID>',\n  },\n  queries: [\n    {\n      refId: 'A',\n      expr: 'rate(prometheus_http_requests_total{}[5m])',\n    },\n  ],\n});\n\nconst myScene = new EmbeddedScene({\n  $data: queryRunner,\n  body: new SceneFlexLayout({\n    direction: 'column',\n    children: [\n      new SceneFlexItem({\n        body: new VizPanel({\n          pluginId: 'timeseries',\n          title: 'Time series',\n        }),\n      }),\n      new SceneFlexItem({\n        body: new VizPanel({\n          pluginId: 'table',\n          title: 'Table',\n        }),\n      }),\n    ],\n  }),\n});\n")),(0,i.kt)("p",null,"The above example will render two panels, a Timeseries and a Table panel."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"For ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneFlexItems")," that contain a ",(0,i.kt)("inlineCode",{parentName:"p"},"VizPanel"),", it's usually a good idea to set ",(0,i.kt)("inlineCode",{parentName:"p"},"minHeight")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"minWidth")," constraints so they don't get squashed too small by limited screen space.")),(0,i.kt)("h3",{id:"responsive-flex-layouts"},"Responsive flex layouts"),(0,i.kt)("p",null,"By default SceneFlexLayout has some responsive behaviors for smaller screens. These kick in for screens that match the media query of Grafana's theme.breakpoints.down('md')."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SceneFlexLayout direction will change from row to column."),(0,i.kt)("li",{parentName:"ul"},"SceneFlexLayout maxWidth, maxHeight, height or width constraints are removed."),(0,i.kt)("li",{parentName:"ul"},"SceneFlexLayout and SceneFlexItem will use the minHeight or height set on the parent layout (unless specified on it directly). This is to make a height or minHeight constraint set on a SceneFlexLayout with direction row also apply to it's children so that when the responsive media query that changes direction to column kicks in these constaints are still acting on the children.")),(0,i.kt)("p",null,"You can override these behaviors and set custom direction and size constraints using the ",(0,i.kt)("inlineCode",{parentName:"p"},"md")," property that exist on both SceneFlexLayout and SceneFlexItem."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"new SceneFlexLayout({\n  direction: 'row',\n  minHeight: 200,\n  md: {\n    minHeight: 100,\n    direction: 'row',\n  },\n  children: [getStatPanel({}), getStatPanel({})],\n}),\n")),(0,i.kt)("p",null,"In the above example we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"md")," property to override the default responsive behavior that changes a ",(0,i.kt)("inlineCode",{parentName:"p"},"row")," layout to a ",(0,i.kt)("inlineCode",{parentName:"p"},"column")," layout. We also apply a tighter minHeight constraint."),(0,i.kt)("h2",{id:"grid-layout"},"Grid layout"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridLayout")," allows building scenes as grids. This is the default behavior of Dashboards in Grafana, and grid layout enables adding a similar experience to your scene."),(0,i.kt)("h3",{id:"step-1-create-a-scene-1"},"Step 1. Create a scene"),(0,i.kt)("p",null,"Start using grid layout by creating a scene with ",(0,i.kt)("inlineCode",{parentName:"p"},"body")," configured as ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridLayout"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  body: new SceneGridLayout({}),\n});\n")),(0,i.kt)("h3",{id:"step-2-configure-grid-layout"},"Step 2. Configure grid layout"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridLayout")," allows grid behavior configuration. The provided grid has 24 columns."),(0,i.kt)("p",null,"You can configure the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isDraggable")," - configure whether or not grid items can be moved."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isLazy")," - configure whether or not grid items should be initialized when they are outside of the viewport.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  body: new SceneGridLayout({\n    isDraggable: false,\n    isLazy: true,\n  }),\n});\n")),(0,i.kt)("h3",{id:"step-3-add-layout-children-1"},"Step 3. Add layout children"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridLayout")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," property. It accepts an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridItem")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridRow")," objects.\nCreate scene with two grid item in a row:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  body: new SceneGridLayout({\n    children: [\n      new SceneGridItem({\n        x: 0,\n        y: 0,\n        width: 12,\n        height: 10,\n        isResizable: false,\n        isDraggable: false,\n      }),\n      new SceneGridItem({\n        x: 12,\n        y: 0,\n        width: 12,\n        height: 10,\n        isResizable: false,\n        isDraggable: false,\n      }),\n    ],\n  }),\n});\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridItem")," accepts the following configuration options. Options are expressed in 24 columns grid units."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n")),(0,i.kt)("h3",{id:"step-4-add-panels-to-grid-layout-items"},"Step 4. Add panels to grid layout items"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#step-4-add-panels-to-flex-layout-items"},"Similarily to flexbox layout"),", add ",(0,i.kt)("inlineCode",{parentName:"p"},"VizPanel")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridItem")," to show visualized data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const myScene = new EmbeddedScene({\n  $data: queryRunner,\n  body: new SceneGridLayout({\n    children: [\n      new SceneGridItem({\n        x: 0,\n        y: 0,\n        width: 12,\n        height: 10,\n        isResizable: false,\n        isDraggable: false,\n        body: new VizPanel({\n          pluginId: 'timeseries',\n          title: 'Time series',\n        }),\n      }),\n      new SceneGridItem({\n        x: 12,\n        y: 0,\n        width: 12,\n        height: 10,\n        isResizable: false,\n        isDraggable: false,\n        body: new VizPanel({\n          pluginId: 'table',\n          title: 'Table',\n        }),\n      }),\n    ],\n  }),\n});\n")),(0,i.kt)("h3",{id:"step-5-add-a-grid-row"},"Step 5. Add a grid row"),(0,i.kt)("p",null,"Grid row is a layout item that groups other ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridItems")," into a collapsible row. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridRow")," add a row to Scene:"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneGridRow")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," coordinates are relative to the row.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const row = new SceneGridRow({\n  x: 0,\n  y: 0,\n  children: [\n    new SceneGridItem({\n      x: 0,\n      y: 0,\n      width: 12,\n      height: 10,\n      isResizable: false,\n      isDraggable: false,\n      body: new VizPanel({\n        pluginId: 'timeseries',\n        title: 'Time series',\n      }),\n    }),\n    new SceneGridItem({\n      x: 12,\n      y: 0,\n      width: 12,\n      height: 10,\n      isResizable: false,\n      isDraggable: false,\n      body: new VizPanel({\n        pluginId: 'table',\n        title: 'Table',\n      }),\n    }),\n  ],\n});\n\nconst myScene = new EmbeddedScene({\n  $data: queryRunner,\n  body: new SceneGridLayout({\n    children: [row],\n  }),\n});\n")))}p.isMDXComponent=!0}}]);