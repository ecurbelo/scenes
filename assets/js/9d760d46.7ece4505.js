"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[184],{876:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>b});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),l=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(i.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(t),m=r,b=d["".concat(i,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(b,c(c({ref:n},u),{},{components:t})):a.createElement(b,c({ref:n},u))}));function b(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,c=new Array(o);c[0]=m;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s[d]="string"==typeof e?e:r,c[1]=s;for(var l=2;l<o;l++)c[l]=t[l];return a.createElement.apply(null,c)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6219:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(7896),r=(t(2784),t(876));const o={id:"core-concepts",title:"Core concepts"},c=void 0,s={unversionedId:"core-concepts",id:"core-concepts",title:"Core concepts",description:"Scene",source:"@site/../docs/core-concepts.md",sourceDirName:".",slug:"/core-concepts",permalink:"/scenes/docs/core-concepts",draft:!1,editUrl:"https://github.com/grafana/scenes/edit/main/docusaurus/website/../docs/core-concepts.md",tags:[],version:"current",frontMatter:{id:"core-concepts",title:"Core concepts"},sidebar:"docs",previous:{title:"Set up Scenes",permalink:"/scenes/docs/getting-started"},next:{title:"Building a scene layout",permalink:"/scenes/docs/scene-layout"}},i={},l=[{value:"Scene",id:"scene",level:2},{value:"Scene object",id:"scene-object",level:2},{value:"State",id:"state",level:2},{value:"Subscribing to state changes",id:"subscribing-to-state-changes",level:3},{value:"Modifying state",id:"modifying-state",level:3},{value:"Data and time range",id:"data-and-time-range",level:2}],u={toc:l},d="wrapper";function p(e){let{components:n,...o}=e;return(0,r.kt)(d,(0,a.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"scene"},"Scene"),(0,r.kt)("p",null,"Scene is a collection of objects, called scene objects. These objects represent different aspects of the Scene: data, time ranges, variables, layout, visualizations. Combined together, scene objects form an object tree."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Scene objects tree",src:t(2501).Z,width:"1341",height:"921"})),(0,r.kt)("p",null,"Scene allows to group and nest object. Things like data, time range or variables can be added to any object in the tree, making them accessible to that object and all descendant objects. Thanks to this, Scene allows to create dashboards that have multiple time ranges, queries that can be shared and transformed, or nested variables."),(0,r.kt)("p",null,"@grafana/scenes comes with multiple objects to solve common problems, like ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneQueryRunner"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneFlexLayout"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"VizPanel")," and more. But you can also create your own scene objects to extend the functionality."),(0,r.kt)("h2",{id:"scene-object"},"Scene object"),(0,r.kt)("p",null,"Scene is built from atomic objects called scene objects. Here's an example of a simple Counter scene object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\nimport { SceneObjectState, SceneObjectBase, SceneComponentProps } from '@grafana/scenes';\n\n// 1. Create interface that describes state of the scene object\ninterface CounterState extends SceneObjectState {\n  count: number;\n}\n\n// 2. Create a scene object\nexport class Counter extends SceneObjectBase<CounterState> {\n  public static Component = CounterRenderer;\n\n  public constructor() {\n    super({\n      count: 0,\n    });\n  }\n\n  public onIncrement = () => {\n    this.setState({\n      count: this.state.count + 1,\n    });\n  };\n}\n\n// 3. Create a component that renders and interacts with the scene object\nfunction CounterRenderer({ model }: SceneComponentProps<Counter>) {\n  const { count } = model.useState();\n\n  return (\n    <div>\n      <div>Counter: {count}</div>\n      <button onClick={model.onIncrement}>Increase</button>\n    </div>\n  );\n}\n")),(0,r.kt)("h2",{id:"state"},"State"),(0,r.kt)("p",null,"Scene object can have a state. The shape of object's state is expressed via an interface that ",(0,r.kt)("em",{parentName:"p"},"must")," extend ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneObjectState")," interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"interface CounterState extends SceneObjectState {\n  count: number;\n}\n")),(0,r.kt)("h3",{id:"subscribing-to-state-changes"},"Subscribing to state changes"),(0,r.kt)("p",null,"The component can read the state from scene object by using ",(0,r.kt)("inlineCode",{parentName:"p"},"model")," prop that it receives when rendered. To subscribe to state changes, call ",(0,r.kt)("inlineCode",{parentName:"p"},"model.useState")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function CounterRenderer({ model }: SceneComponentProps<Counter>) {\n  const { count } = model.useState();\n\n  // ...\n}\n")),(0,r.kt)("p",null,"Subscribing to object's state using ",(0,r.kt)("inlineCode",{parentName:"p"},"model.useState()")," will make the component reactive to state changes. Every change to the scene object state is immutable and will cause a re-render of the component."),(0,r.kt)("h3",{id:"modifying-state"},"Modifying state"),(0,r.kt)("p",null,"To change the state of the scene object, use ",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," method that each scene object has. This can be done directly from the component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function CounterRenderer({ model }: SceneComponentProps<Counter>) {\n  const { count } = model.useState();\n  const onIncrement = () => model.setState({ count: count + 1 });\n\n  // ...\n}\n")),(0,r.kt)("p",null,"Or in the scene object class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"export class Counter extends SceneObjectBase<CounterState> {\n  // ...\n  public onIncrement = () => {\n    this.setState({\n      count: this.state.count + 1,\n    });\n  };\n}\n\nfunction CounterRenderer({ model }: SceneComponentProps<Counter>) {\n  const { count } = model.useState();\n\n  return (\n    <div>\n      <div>Counter: {count}</div>\n      <button onClick={model.onIncrement}>Increase</button>\n    </div>\n  );\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We suggest to implement the state-modifying methods in the scene object rather than component to separate the model complexity from the component.")),(0,r.kt)("h2",{id:"data-and-time-range"},"Data and time range"),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"$data")," property to add data coming from Grafana data sources to a Scene. Queries are configured via ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneQueryRunner")," scene object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { SceneQueryRunner } from '@grafana/scenes';\n\nconst queryRunner = new SceneQueryRunner({\n  datasource: {\n    type: 'prometheus',\n    uid: '<PROVIDE_GRAFANA_DS_UID>',\n  },\n  queries: [\n    {\n      refId: 'A',\n      expr: 'rate(prometheus_http_requests_total{}[5m])',\n    },\n  ],\n});\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Keep in mind that your Grafana instance must have specified data source configured.")),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneQueryRunner")," to work, a time range has to be added to a Scene. Each scene object has ",(0,r.kt)("inlineCode",{parentName:"p"},"$timeRange")," property to which ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneTimeRange")," scene object can be added. To specify time range for the query runner created in previous example, add ",(0,r.kt)("inlineCode",{parentName:"p"},"$timeRange")," property in the object passed to the constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { SceneQueryRunner, SceneTimeRange } from '@grafana/scenes';\n\nconst queryRunner = new SceneQueryRunner({\n  datasource: {\n    type: 'prometheus',\n    uid: '<PROVIDE_GRAFANA_DS_UID>',\n  },\n  queries: [\n    {\n      refId: 'A',\n      expr: 'rate(prometheus_http_requests_total{}[5m])',\n    },\n  ],\n  $timeRange: new SceneTimeRange({ from: 'now-5m', to: 'now' }),\n});\n")),(0,r.kt)("p",null,"Add created ",(0,r.kt)("inlineCode",{parentName:"p"},"queryRunner")," to your scene. Each object in the scene will now be able to access the provided data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const scene = new EmbeddedScene({\n    $data: queryRunner,\n    body: ...\n})\n")),(0,r.kt)("p",null,"Each scene object has ",(0,r.kt)("inlineCode",{parentName:"p"},"$data")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"$timeRange")," property that can be configured. Given that Scene is a objects tree, data provided via ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneQueryRunner")," and time range configured via ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneTimeRange")," is accessible to the object those are added to ",(0,r.kt)("em",{parentName:"p"},"and")," all descendant objects."),(0,r.kt)("p",null,"In the following example, each ",(0,r.kt)("inlineCode",{parentName:"p"},"VizPanel")," use different data. Panel A uses data defined on the ",(0,r.kt)("inlineCode",{parentName:"p"},"EmbeddedScene"),", while Panel B has it's own data and time range configured:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// Scene data, used by Panel A\nconst queryRunner1 = new SceneQueryRunner({\n  datasource: {\n    type: 'prometheus',\n    uid: '<PROVIDE_GRAFANA_DS_UID>',\n  },\n  queries: [\n    {\n      refId: 'A',\n      expr: 'rate(prometheus_http_requests_total{}[5m])',\n    },\n  ],\n  $timeRange: new SceneTimeRange({ from: 'now-5m', to: 'now' }),\n});\n\n// Panel B data\nconst queryRunner2 = new SceneQueryRunner({\n  datasource: {\n    type: 'prometheus',\n    uid: '<PROVIDE_GRAFANA_DS_UID>',\n  },\n  queries: [\n    {\n      refId: 'A',\n      expr: 'avg by (job, instance, mode) (rate(node_cpu_seconds_total[5m]))',\n    },\n  ],\n});\n\nconst scene = new EmbeddedScene({\n  $data: queryRunner1,\n  body: new SceneFlexLayout({\n    direction: 'row',\n    children: [\n      new SceneFlexItem({\n        width: '50%',\n        height: 300,\n        body: new VizPanel({ title: 'Panel A', pluginId: 'timeseries' }),\n      }),\n      new SceneFlexItem({\n        width: '50%',\n        height: 300,\n        body: new VizPanel({\n          title: 'Panel B',\n          pluginId: 'timeseries',\n          $data: queryRunner2,\n          // Time range defined on VizPanel objectt. queryRunner2 will use this time range.\n          $timeRange: new SceneTimeRange({ from: 'now-6h', to: 'now' }),\n        }),\n      }),\n    ],\n  }),\n});\n")))}p.isMDXComponent=!0},2501:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/sceneTree-d39fdb5e339a83eebcaf46985cc778e6.png"}}]);